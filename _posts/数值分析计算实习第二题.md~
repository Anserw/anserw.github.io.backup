title: 数值分析计算实习第二题
date: 2015-11-13 21:55:55
tags:
 - 数值分析
 - c
---
## 1. 题目描述
试求矩阵$A=[a_{ij}]_{10\times10}$的全部特征值，并对其中的每一个实特征值求相应的特征向量。已知 
$$a_{i,j}=\left\{\begin{matrix}sin(0.5i+0.2j)
 & i\neq j\\1.52cos(i+1.2j) 
 & i=j
\end{matrix}\right. \qquad   (i,j=1,2,\cdots ,10)$$

### 说明： 
1. 求矩阵特征值时，要求迭代的精度水平为$\varepsilon=10^{-12} $
2. 打印以下内容： 
    - 全部源程序。 
    - 矩阵$A$经过拟上三角化后所得的矩阵$A^{(n-1)}$
    - 对矩阵$A^{(n-1)}$实行QR分解方法结束后所得的矩阵。 
    - 矩阵A的全部特征值$\lambda_i=(R_i, I_i) \ (i=1,2,\cdots ,10)$，其中$R_i=Re(\lambda_i), I_i=Im(\lambda_i)$，若$\lambda_i$是实数，就令$I_i=0$。 
    - 矩阵$A$的相应于实特征值的特征向量。 
3. 采用e型输出实型数，并且至少显示12位有效数字。

## 2. 算法设计

```flow
st=>start: Start
e=>end: end
op0=>operation: 初始化矩阵，计算初值
op1=>operation: 矩阵的拟上三角化
op2=>operation: 用带双步位移的QR方法求解所有特征值
cond1=>condition: 判断是否是实特征值
op3=>operation: 用Gauss消去法求解对应的特征向量
io=>inputoutput: 输出结果
st->op0->op1->op2->cond1
cond1(yes)->op3
cond1(no)->io
op3->io
io->e
```


1. 拟上三角化
按照*数值分析, 闫庆津, 第四版*中61页3.3.2的方法，求得矩阵A经过拟上三角化后的矩阵$A^{(n-1)}$。
此步可以为后续计算减少计算量。

2. 带双步位移的QR方法
按照*数值分析, 闫庆津, 第四版*中62页3.3.3的方法。
QR方法产生的矩阵序列本质上收敛于分块上三角阵。对角块均是一阶或二阶子块，对每个子块求特征值就得到整个矩阵的所有特征值。为加速收敛，采用带双步位移的QR分解法。记最大迭代次数为Max，取为1000，迭代精度为e=1e-12。
每次迭代前检查，若下一个子块满足条件（一阶或二阶），输所有特征值，计算完成。若达到最大迭代次数仍未输出所有特征值，则返回错误信息，计算失败。

3. 列主元素Gauss消去法
按照*数值分析, 闫庆津, 第四版*中16页2.1.2的方法。
对每个实特征值$λ_i$，解线性方程$(A-λ_i I)X=0$，因为系数矩阵非满秩的，统一置特征向量的最后一个值为1。

## 3. 程序代码
```cpp
//compute_practice_2.cpp 
//带双步位移的QR方法

#include<stdio.h>
#include<stdlib.h>
#include<math.h>

const double e = 1e-12;      //迭代的精度水平
const int Max = 1000;        //迭代的最大次数

//定义复数结构体
typedef struct{
    double Re;
    double Im;
}ComplexNumber;

//初始化矩阵
void initMat(double **& a)
{
    int i, j;
    a = (double **)malloc(10 * sizeof(double *));
    for (i = 0; i<10; i++)
        a[i] = (double *)malloc(11 * sizeof(double));
    for (i = 0; i<10; i++) {
        for (j = 0; j<10; j++) {
            if (i != j)
                a[i][j] = sin(0.5*(i + 1) + 0.2*(j + 1));
            else
                a[i][j] = 1.52*cos(i + 1 + 1.2*(j + 1));
        }
    }
}

//将矩阵中小于e的值全部赋值为0
void zeroMat(double **a)
{
    int i, j;
    for (i = 0; i<10; i++) {
        for (j = 0; j<10; j++) {
            if (a[i][j]<e&&a[i][j]>-e)
                a[i][j] = 0;
        }
    }
}

//输出矩阵
int printMat(double **a)
{
    int i, j;
    for (i = 0; i<10; i++)
    {
        for (j = 0; j<10; j++)
            printf("%.12e ", a[i][j]);
        printf("\n");
    }
    printf("\n\n\n");
    return 0;
}

//将矩阵拟上三角化
void hessenbergMat(double **a)       
{
    int r, i, j;
    double c, d, h, t, u[10], p[10], q[10], w[10];
    for (r = 0; r<8; r++) {
        zeroMat(a);
        c = 0; d = 0; h = 0;
        for (i = r + 2; i<10; i++)
            d += a[i][r] * a[i][r];
        if (d == 0)
            continue;
        else {
            d += a[r + 1][r] * a[r + 1][r];
            d = pow(d, 0.5);
            if (a[r + 1][r] != 0)
                c = -fabs(a[r + 1][r]) / a[r + 1][r] * d;
            else 
                c = d;
            h = c*c - c*a[r + 1][r];
            for (i = 0; i<r + 1; i++)
                u[i] = 0;
            u[r + 1] = a[r + 1][r] - c;
            for (i = r + 2; i<10; i++) 
                u[i] = a[i][r];
            for (i = 0; i<10; i++) {
                p[i] = 0; q[i] = 0;
                for (j = 0; j<10; j++) {
                    p[i] += a[j][i] * u[j] / h;
                    q[i] += a[i][j] * u[j] / h;
                }
            }
            t = 0;
            for (i = 0; i<10; i++)
                t += p[i] * u[i] / h;
            for (i = 0; i<10; i++)
                w[i] = q[i] - t*u[i];
            for (i = 0; i<10; i++) {
                for (j = 0; j<10; j++)
                    a[i][j] -= (w[i] * u[j] + u[i] * p[j]);
            }
        }
    }
	printf("A(n-1)\n");
	zeroMat(a);
	printMat(a);
}

//矩阵乘法
void muiltiplyMat(double **a, double **b, double **c, int m)
{    
    for (int i = 0; i<m; i++) {
        for (int j = 0; j<m; j++) {
            c[i][j] = 0;
            for (int k = 0; k<m; k++)
                c[i][j] += a[i][k] * b[k][j];
        }
    }
}

//QR分解中的迭代运算
void iterate(double **M, double **a, int m)
{
    int r, i, j;
    double c, d, h, t, u[10], v[10], p[10], q[10], w[10];
    for (r = 0; r<m - 1; r++) {
        zeroMat(M);
        c = 0; d = 0; h = 0;
        for (i = r + 1; i<m; i++)
            d += M[i][r] * M[i][r];
        if (fabs(d) == 0)
            continue;
        else {
            d += M[r][r] * M[r][r];
            d = pow(d, 0.5);
            if (M[r][r] != 0)
                c = -fabs(M[r][r]) / M[r][r] * d;
            else 
                c = d;
            h = c*c - c*M[r][r];
            for (i = 0; i<r; i++)u[i] = 0;
            u[r] = M[r][r] - c;
            for (i = r + 1; i<m; i++) 
                u[i] = M[i][r];
            for (i = 0; i<m; i++) {
                v[i] = 0;
                for (j = 0; j<m; j++)
                    v[i] += M[j][i] * u[j] / h;
            }
            for (i = 0; i<m; i++) {
                p[i] = 0; q[i] = 0;
                for (j = 0; j<m; j++) {
                    M[i][j] -= u[i] * v[j];
                    p[i] += a[j][i] * u[j] / h;
                    q[i] += a[i][j] * u[j] / h;
                }
            }
            t = 0;
            for (i = 0; i<m; i++)
                t += p[i] * u[i] / h;
            for (i = 0; i<m; i++)
                w[i] = q[i] - t*u[i];
            for (i = 0; i<m; i++) {
                for (j = 0; j<m; j++) {
                    a[i][j] -= (w[i] * u[j] + u[i] * p[j]);
                }
            }
        }
    }
}

//Gauss消元法中的选主元
void maxline(double **ptr, int n, int k)
{
    double c;
    int i, M;
    M = k;
    for (i = k; i<n; i++) {
        if (fabs(ptr[i][k])>fabs(ptr[M][k]))
            M = i;
    }
    if (M>k) {
        for (i = k; i<n + 1; i++) {
            c = ptr[k][i];
            ptr[k][i] = ptr[M][i];
            ptr[M][i] = c;
        }
    }
}

//Gauss消元法
void gauss(double lambda)
{
    double **a;
    double *X;
    double m, sigma, t;
    int i, j, k, n = 10;
    X = (double *)malloc(10 * sizeof(double));
    initMat(a);

    for (i = 0; i<n; i++) {
        a[i][i] -= lambda;
        a[i][10] = 0;
    }

    for (k = 0; k<n - 1; k++) {
        maxline(a, n, k);
        for (i = k + 1; i<n; i++) {
            m = a[i][k] / a[k][k];
            for (j = k; j<n + 1; j++)
                a[i][j] = a[i][j] - m*a[k][j];
        }
    }

    X[n - 1] = 1;    
	t = 0;
    for (k = n - 2; k >= 0; k--) {
        sigma = 0;
        for (j = k + 1; j<n; j++)
            sigma += a[k][j] * X[j];
        X[k] = (a[k][n] - sigma) / a[k][k];
    }
	for (i = 0; i<n; i++)
		t += X[i] * X[i];
	t = sqrt(t);
    printf("eigenvector = ( ");
    for (i = 0; i<n; i++)
        printf("%.12e ", X[i]/t);
    printf(")\n");
    for (i = 0; i<10; i++)
        free(a[i]);
    free(a);
    free(X);
}

//带双步位移的QR分解方法
void QRmethod(double **a)
{
    int k, m, i, j, r;
    double s, t, det;
    double **M;
    ComplexNumber L[10];    
    M = (double**)malloc(10 * sizeof(double *));
    for (k = 0; k<10; k++)
        M[k] = (double*)malloc(10 * sizeof(double));

    m = 9; r = 0;
    for (k = 0; k<Max; k++)
    {
        if (m == 0) {
            L[r].Re = a[m][m];
            L[r].Im = 0; break;
        }
        else if (m < 0) {
            break;
        }
        if (fabs(a[m][m - 1])<e) {
            L[r].Re = a[m][m];
            L[r].Im = 0;
            m--; r++;
        }
        else {
            if (m == 1) {
                det = (a[m][m] + a[m - 1][m - 1])*(a[m][m] + a[m - 1][m - 1]) - 4 * (a[m][m] * a[m - 1][m - 1] - a[m - 1][m] * a[m][m - 1]);
                if (det > 0) {
                    L[r].Re = (a[m][m] + a[m - 1][m - 1]) / 2 + sqrt(det) / 2;
                    L[r].Im = 0;
                    L[r + 1].Re = (a[m][m] + a[m - 1][m - 1]) / 2 - sqrt(det) / 2;
                    L[r + 1].Im = 0;
                }
                else {
                    L[r].Re = (a[m][m] + a[m - 1][m - 1]) / 2;
                    L[r].Im = sqrt(-det) / 2;
                    L[r + 1].Re = (a[m][m] + a[m - 1][m - 1]) / 2;
                    L[r + 1].Im = -sqrt(-det) / 2;
                }
                m -= 2;
                r += 2;
                continue;
            }
            else if (fabs(a[m - 1][m - 2])<e) {
                det = (a[m][m] + a[m - 1][m - 1])*(a[m][m] + a[m - 1][m - 1]) - 4 * (a[m][m] * a[m - 1][m - 1] - a[m - 1][m] * a[m][m - 1]);
                if (det>0) {
                    L[r].Re = (a[m][m] + a[m - 1][m - 1]) / 2 + sqrt(det) / 2;
                    L[r].Im = 0;
                    L[r + 1].Re = (a[m][m] + a[m - 1][m - 1]) / 2 - sqrt(det) / 2;
                    L[r + 1].Im = 0;
                }
                else {
                    L[r].Re = (a[m][m] + a[m - 1][m - 1]) / 2;
                    L[r].Im = sqrt(-det) / 2;
                    L[r + 1].Re = (a[m][m] + a[m - 1][m - 1]) / 2;
                    L[r + 1].Im = -sqrt(-det) / 2;
                }
                m -= 2;
                r += 2; 
                continue;
            }
            else {
                s = a[m - 1][m - 1] + a[m][m];
                t = a[m - 1][m - 1] * a[m][m] - a[m][m - 1] * a[m - 1][m];
                muiltiplyMat(a, a, M, m + 1);
                for (i = 0; i<10; i++)
                {
                    for (j = 0; j<10; j++)
                        M[i][j] -= s*a[i][j];
                    M[i][i] += t;
                }
                iterate(M, a, m + 1);
                zeroMat(a);
            }
        }
    }
    zeroMat(a);
	printf("after QR method\n");
    printMat(a);
    
    for (int r = 0; r<10; r++) {
		printf("\n");
        if (L[r].Im == 0) {
            printf("lambda[%d] = (%.12e + i*%.12e)\n", r + 1, L[r].Re, L[r].Im);
            gauss(L[r].Re);
        }
        else {
            printf("lambda[%d] = (%.12e + i*%.12e)\n", r + 1, L[r].Re, L[r].Im);
        }
    }
}

int main()
{
    double **a;
    initMat(a);    
    hessenbergMat(a);    
    QRmethod(a);
    return 0;
}
```
## 4. 运行结果
![1](http://7xkr5h.com1.z0.glb.clouddn.com/numerical_analysis_compute_practice_2_1.png)
![2](http://7xkr5h.com1.z0.glb.clouddn.com/numerical_analysis_compute_practice_2_2.png)
即
```
矩阵A经过拟上三角化后所得的矩阵A(n-1)
-8.945216982281e-01 -9.933136491826e-02 -1.099831758877e+00 -7.665038709077e-01 1.707601141456e-01 -1.934882558889e+00 -8.390208705246e-02 9.132565113143e-01 -6.407977009188e-01 1.946733678685e-01 
-2.347878362416e+00 2.372057921598e+00 1.827998552316e+00 3.266556884714e-01 2.082360583635e-01 2.088987009941e+00 1.847861910289e-01 -1.263015266080e+00 6.790694668499e-01 -4.672150886500e-01 
0.000000000000e+00 1.735954469946e+00 -1.165023367477e+00 -1.246744443518e+00 -6.298225489084e-01 -1.984820180992e+00 2.975750060800e-01 6.339300596595e-01 -1.308518928772e-01 3.040301036095e-01 
0.000000000000e+00 0.000000000000e+00 -1.292937563924e+00 -1.126239225902e+00 1.190782911924e+00 -1.308772983895e+00 1.860151662666e-01 4.236733936881e-01 -1.019600826545e-01 1.943660914505e-01 
0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 1.577711153032e+00 8.169358328160e-01 4.461531723828e-01 -4.365092541609e-02 -4.665979167188e-01 2.941231566184e-01 -1.034421113665e-01 
0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 -7.728975134989e-01 -1.601028244046e+00 -2.912685474827e-01 -2.434337858321e-01 6.736286084510e-01 2.624772904937e-01 
0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 -7.296773946362e-01 -7.965456279819e-03 9.710739102007e-01 -1.298967368574e-01 2.780242081241e-02 
0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 7.945539612976e-01 -4.525143454606e-01 5.048901527575e-01 -1.211210193512e-01 
0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 7.039911373514e-01 1.267535523498e-01 -3.714696735513e-01 
0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 -4.919586872214e-01 4.081509766399e-01 

对矩阵A(n-1)实行QR方法迭代结束后所得的矩阵
3.389613438816e+00 8.353528415090e-01 -9.407588813616e-01 -8.836679698649e-02 2.662153718304e-01 9.208193563524e-01 -1.679190487850e+00 -7.649131336009e-02 9.684803888362e-01 -4.210340078049e-01 
0.000000000000e+00 -2.255459308097e+00 -2.369631451720e+00 4.483599022450e-02 -4.302583441345e-02 1.501664034048e+00 -1.100436653664e+00 1.606195241269e-01 5.797745141984e-01 6.122186271245e-02 
0.000000000000e+00 3.396555006850e-01 -2.418272556380e+00 6.381930767886e-01 2.168626103991e-02 1.687949829672e+00 -7.224251387618e-01 3.064680671409e-01 -1.977953231143e+00 1.049171012963e+00 
0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 1.590313467616e+00 1.546247056096e-02 -5.428692404289e-01 4.801586897193e-01 -7.278886615548e-03 8.015966164161e-02 -1.137955835345e-01 
0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 -1.756760412591e-06 -1.493147089725e+00 -7.096494288025e-02 8.624881081845e-02 -3.413451773294e-02 -1.213263562611e-01 -1.053724502475e-01 
0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 -9.816114823730e-01 -6.990660582700e-01 -2.535373674083e-01 5.841485452134e-01 -5.129627522854e-01 
0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 1.691300230644e-02 -9.966172105716e-01 -1.135339714312e-01 -2.838529399430e-01 -4.005028591510e-02 
0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 9.432879572769e-01 1.855615509918e-01 -1.449241416203e-01 
0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 6.418381898385e-01 -2.915442416256e-01 
0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 -1.444563958423e-02 5.666053960893e-02 

全部特征值以及实特征值对应的特征向量
lambda[1] = (6.489488202111e-01 + i*0.000000000000e+00)
eigenvector = ( 1.084347985769e-01 7.134412595430e-02 3.825016669472e-01 -4.710034333103e-02 -7.178036005646e-01 1.815185466487e-01 -2.260059384135e-01 3.883814676961e-01 2.896964248456e-01 2.433276829523e-02 )

lambda[2] = (4.954990923633e-02 + i*0.000000000000e+00)
eigenvector = ( -2.137679779588e-01 -2.067736216989e-01 3.868289835104e-01 -3.111239463633e-02 -3.809389602373e-01 -1.251737268117e-01 6.447157358387e-01 -3.082012729665e-01 -2.959767270125e-01 4.372295101355e-02 )

lambda[3] = (9.432879572769e-01 + i*0.000000000000e+00)
eigenvector = ( 7.961973168490e-02 4.542056844048e-02 -1.827195427638e-02 -4.796091671390e-02 -3.495674270700e-01 2.072147711559e-01 -1.523120734300e-01 8.206337104041e-01 -3.554663294321e-01 2.886595340973e-02 )

lambda[4] = (-9.891143464723e-01 + i*1.084758631502e-01)

lambda[5] = (-9.891143464723e-01 + i*-1.084758631502e-01)

lambda[6] = (1.590313458807e+00 + i*0.000000000000e+00)
eigenvector = ( 6.237689761292e-02 -1.123122952786e-02 -2.528460320943e-01 -1.309875813614e-01 -3.819851386409e-01 8.155752888362e-01 -1.233767829110e-01 -6.772145198981e-02 2.719446111546e-01 1.002822249993e-01 )

lambda[7] = (-1.493147080915e+00 + i*0.000000000000e+00)
eigenvector = ( -5.613409816979e-01 7.781923574579e-01 1.436371665877e-02 -2.776019037479e-01 3.568072419003e-03 -2.548341655989e-03 -2.206089878200e-02 -1.175827116960e-02 -1.317349848144e-02 3.501595772874e-02 )

lambda[8] = (-2.336865932239e+00 + i*8.934379210213e-01)

lambda[9] = (-2.336865932239e+00 + i*-8.934379210213e-01)

lambda[10] = (3.389613438816e+00 + i*0.000000000000e+00)
eigenvector = ( -1.048719993204e-01 -2.176769763196e-01 -4.746940122415e-01 -2.593836246507e-01 -3.046652485206e-01 -2.594517466617e-01 8.686641827337e-02 4.052581266927e-01 5.096282896431e-01 2.395146921660e-01 )
```

## 5. 问题与分析
带双步位移的QR方法中，在复数的处理上遇到了问题。由于没有顾及到复数解，在初次运行时并没有得到正确的结果。后自行定义的复数的类型，解决了这个问题。
