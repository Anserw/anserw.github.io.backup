title: 改善C++程序与设计 「5」 实现
date: 2015-12-08 20:31:49
tags: 
- C++ 
- 读书笔记
- Effective C++
---
## 尽可能延后变量定义式的出现时间
1. 直到使用变量前再定义，可避免因抛出异常而造成的资源泄露和浪费构造成本，还可以避免无意义的default构造行为。
2. 如果变量只在循环内使用，应考虑具体情况
 - 定义在外部: 1个构造函数 + 1个析构函数 + n个赋值操作
 - 定义在内部: n个构造函数 + n个析构函数

## 少做转型
- 旧式转型
1. `(T)expression`
2. `T(expression)`
- 新式转型
1. `const_cast`
通常被用来将对象的常量性转除
2. `dynamic_case`
主要用来执行"安全向下转型"。无法由旧式语法执行，可能耗费重大运行成本。
3. `reinterpret_cast`
低级转型，实际效果可能取决于编译器，不可移植。
4. `static_cast`
强迫隐式转换。如将non-`const`对象转为`const`对象，将`int`转为`double`等。或将`void*`指针转为typed指针，将pointer-to-base转为pointer-to-derived。

## 避免返回handles指向对象内部成分
避免返回handles(包括references、指针、迭代器)指向对象内部。遵守这个条款可增加封装性，帮助const成员函数的行为像个const，并将发生"虚吊号码牌"的可能性降至最低。

## 异常安全
- 基本承诺
如果异常被抛出，程序内的任何事物仍然保持在有效状态下。没有任何对象或数据结构会因此而败坏，所有对象都处于一种内部前后一致的状态。
- 强烈保证
如果异常被抛出，程序状态不改变。如果函数成功，就是完全成功；如果失败，程序会回复到"调用函数之前"的状态。往往能够以copy-and-swap实现出来。
- 不抛掷(nothrow)保证
承诺绝不抛出异常。

## inline
- 将大多数inline限制在小型、被频繁调用的函数身上
- 不要只因为function templates出现在头文件，就声明为inline
- 不要把构造函数和析构函数声明为inline

## 将文件间的编译依存关系降至最低
- 支持"编译依存性最小化"的一般构想是: 相依于声明式，不要相依于定义式。基于此构想的两个手段是Handle classes和Interface classes。
- 程序库头文件应该以"完全且仅有的声明式"的形式存在。这种做法不论是否涉及templates都适用。